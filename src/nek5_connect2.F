       subroutine rdcurve2
C
C     .Read curve side data
C
C     .Disperse curve side data to all processors according
C      to sequential partition scheme
C
C
      INCLUDE 'SIZE'
      INCLUDE 'INPUT'
      INCLUDE 'PARALLEL'
      CHARACTER*1 ANS
C
      IFFMTIN=.true. ! current setting
C
      IF (IFFMTIN) THEN   ! FMTIN=ForMaTtedINput
C
C     Read formatted curve side data
C
      READ(9,*)
      READ(9,*)NCURVE
      CALL RZERO(CURVE ,48*LELT)
      CALL BLANK(CCURVE, 8*LELT)
      IF (NCURVE.GT.0) THEN
         DO 50 ICURVE=1,NCURVE
            IF     (NELGT.LT.1000) THEN
               READ(9,60,ERR=500,END=500) IEDG,IEG,R1,R2,R3,R4,R5,ANS
            ELSEIF (NELGT.LT.1000000) THEN
               READ(9,61,ERR=500,END=500) IEDG,IEG,R1,R2,R3,R4,R5,ANS
            ELSEIF (NELGT.LT.10000000) THEN
               READ(9,62,ERR=500,END=500) IEDG,IEG,R1,R2,R3,R4,R5,ANS
            ENDIF
   60       FORMAT(I3,I3,5G14.6,1X,A1) !FIXEME misun 8/14/2014, needt to match prex 
   61       FORMAT(I2,I6,5G14.6,1X,A1)
   62       FORMAT(I1,I7,5G14.6,1X,A1)
            IF (GLLNID(IEG).EQ.NID) THEN
               IEL=GLLEL(IEG)
               CURVE (1,IEDG,IEL)=R1
               CURVE (2,IEDG,IEL)=R2
               CURVE (3,IEDG,IEL)=R3
               CURVE (4,IEDG,IEL)=R4
               CURVE (5,IEDG,IEL)=R5
               CCURVE(  IEDG,IEL)=ANS
            ENDIF
   50    CONTINUE
      ENDIF
      RETURN
C
C     Error handling:
C
  500 CONTINUE
      WRITE(6,501)
  501 FORMAT(2X,'ERROR READING CURVE SIDE DATA'
     $    ,/,2X,'ABORTING IN ROUTINE RDCURVE.')
      call exitt(1)
      RETURN
C
      ELSE
C
C     Read unformatted curve side data
C
      READ(8) NCURVE
      CALL RZERO(CURVE ,72*LELT)
      CALL BLANK(CCURVE,12*LELT)
      IF (NCURVE.GT.0) THEN
         DO 1050 ICURVE=1,NCURVE
            READ(8,ERR=1500,END=1500) IEDG,IEG,R1,R2,R3,R4,R5,ANS
            IF (GLLNID(IEG).EQ.NID) THEN
               IEL=GLLEL(IEG)
               CURVE (1,IEDG,IEL)=R1
               CURVE (2,IEDG,IEL)=R2
               CURVE (3,IEDG,IEL)=R3
               CURVE (4,IEDG,IEL)=R4
               CURVE (5,IEDG,IEL)=R5
               CCURVE(  IEDG,IEL)=ANS
            ENDIF
 1050    CONTINUE
      ENDIF
      RETURN
C
C     Error handling:
C
 1500 CONTINUE
      WRITE(6,1501)
 1501 FORMAT(2X,'ERROR READING unformatted CURVE SIDE DATA'
     $    ,/,2X,'ABORTING IN ROUTINE RDCURVE.')
      call exitt(1)
C
      RETURN
      ENDIF
      END

      SUBROUTINE RDICDF
C
C     .Read Initial Conditions / Drive Force
C
C     .Broadcast ICFILE to all processors
C
      INCLUDE 'SIZE'
      INCLUDE 'INPUT'
      CHARACTER*80 LINE
      LOGICAL      IFGTIL
C
C     Read Initial Conditions/Restart Files
      CALL BLANK(INITC,1200)
      READ(9,80,ERR=200,END=200) LINE
      IF (INDX1(LINE,'RESTART',7).NE.0) THEN
         IF (.NOT.IFGTIL(NSKIP,LINE)) GOTO 200
c        READ(LINE,*,ERR=200,END=200) NSKIP
         DO 50 I=1,NSKIP
            READ(9,80,ERR=200,END=200) INITC(I)
   50    CONTINUE
         READ(9,80,ERR=200,END=200) LINE
      ENDIF
   80 FORMAT(A80)
      IF (.NOT.IFGTIL(NSKIP,LINE)) GOTO 200
c     READ(LINE,*,ERR=200,END=200)NSKIP
      DO 100 I=1,NSKIP
         READ(9,80,ERR=200,END=200) LINE
  100 CONTINUE
C     Read drive force data
      READ(9,*,ERR=200,END=200)
      READ(9,*,ERR=200,END=200) NSKIP
      DO 110 I=1,NSKIP
        READ(9,80,ERR=200,END=200) LINE
  110 CONTINUE
      RETURN
C
C     Error handling:
C
  200 CONTINUE
      WRITE(6,201)
  201 FORMAT(2X,'ERROR READING INITIAL CONDITION/DRIVE FORCE DATA'
     $    ,/,2X,'ABORTING IN ROUTINE RDICDF.')
      call exitt(1)
C
      RETURN
      END
      SUBROUTINE RDMATP
C
C     .Read materials property data
C
C     .Disperse material properties to all processors according
C      to sequential partition scheme
C
      INCLUDE 'SIZE'
      INCLUDE 'INPUT'
      CHARACTER*80 LINE
C
      CALL IZERO(MATYPE,16*LDIMT1)
      CALL RZERO(CPGRP ,48*LDIMT1)
C
C     Read material property data
C
      READ(9,*,ERR=200,END=200)
      READ(9,*,ERR=200,END=200) NSKIP
      READ(9,*,ERR=200,END=200) NPACKS
      DO 100 IIG=1,NPACKS
         IFVPS=.TRUE.
         READ(9,*)IGRP,IFLD,ITYPE
         MATYPE(IGRP,IFLD)=ITYPE
         DO 100 IPROP=1,3
            IF(ITYPE.EQ.1) READ(9,* ) CPGRP(IGRP,IFLD,IPROP)
            IF(ITYPE.EQ.2) READ(9,80) LINE
   80 FORMAT(A80)
  100 CONTINUE
C
      RETURN
C
C     Error handling:
C
  200 CONTINUE
      WRITE(6,201)
  201 FORMAT(2X,'ERROR READING MATERIAL PROPERTIES DATA'
     $    ,/,2X,'ABORTING IN ROUTINE RDMATP.')
      call exitt(1)
C
      RETURN
      END
      SUBROUTINE RDHIST
C
C     .Read history data
C
C     .Broadcast to all processors
C
      INCLUDE 'SIZE'
      INCLUDE 'INPUT'
      INCLUDE 'PARALLEL'
C
      CALL BLANK (HCODE ,11*lhis)
      CALL IZERO (LOCHIS, 4*lhis)
C
C     Read history data
      READ (9,*)
      READ (9,*,ERR=200,END=200) NHIS
      if (nhis.gt.lhis) then
         write(6,*) nid,' Too many history pts. RESET LHIS.',nhis,lhis
         call exitt(1)
      endif
c
C     HCODE(10) IS WHETHER IT IS HISTORY, STREAKLINE, PARTICLE, ETC.
      if (nhis.gt.0) then
         do i=1,nhis
            if (nelgt.lt.100000) then
               read(9,130,err=200,end=200)
     $         (hcode(ii,i),ii=1,11),(lochis(i2,i),i2=1,4)
  130          format(1x,11a1,1x,4i5)
            else
               read(9,131,err=200,end=200)
     $         (hcode(ii,i),ii=1,11),(lochis(i2,i),i2=1,4)
  131          format(1x,11a1,1x,3i5,i10)
            endif
c
c           threshold lochis locations to allow easy specification of "NX,NY,NZ"
c           pff 1/7/97
c
            if (hcode(10,i).eq.'H') then
               lochis(1,i) = min(lochis(1,i),nx1)
               lochis(2,i) = min(lochis(2,i),ny1)
               lochis(3,i) = min(lochis(3,i),nz1)
c
c              if lochis_k = -1, set it to nxk/2   pff 8/21/03
c
               if (lochis(1,i).eq.-1) lochis(1,i) = (nx1+1)/2
               if (lochis(2,i).eq.-1) lochis(2,i) = (ny1+1)/2
               if (lochis(3,i).eq.-1) lochis(3,i) = (nz1+1)/2
            endif
         enddo
      endif
C
      return
C
C     Error handling:
C
  200 CONTINUE
      WRITE(6,201)
  201 FORMAT(2X,'ERROR READING HISTORY DATA'
     $    ,/,2X,'ABORTING IN ROUTINE RDHIST.')
      call exitt(1)
C
      RETURN
      END
      SUBROUTINE RDOUT
C
C     .Read output specs
C
C     .Broadcast to all processors
C
      INCLUDE 'SIZE'
      INCLUDE 'INPUT'
C
C     Read output specs
      READ(9,*,ERR=200,END=200)
      READ(9,*,ERR=200,END=200) NOUTS
      READ(9,*,ERR=200,END=200) IFXYO
      READ(9,*,ERR=200,END=200) IFVO
      READ(9,*,ERR=200,END=200) IFPO
      READ(9,*,ERR=200,END=200) IFTO
      ! FIXME: Our files only seem to have five of these. Hope this
      ! doesn't matter. Gfortran code (correctly) bails out here.
      ! ak, 8/10/06
      ! READ(9,*,ERR=200,END=200) IFBO   !  IFTGO
      ! READ(9,*,ERR=200,END=200) IPSCO
      !IF (IPSCO.GT.0) THEN
      !   DO I=1,IPSCO
      !      READ(9,*,ERR=200,END=200) IFPSCO(I)
      !   ENDDO
      !ENDIF
C
      RETURN
C
C     Error handling:
C
  200 CONTINUE
      WRITE(6,201)
  201 FORMAT(2X,'ERROR READING OUTPUT SPECIFICATION DATA'
     $    ,/,2X,'ABORTING IN ROUTINE RDOUT.')
      call exitt(1)
C
      RETURN
      END

      SUBROUTINE RDOBJ
C
C     .Read objects
C
C     .Broadcast to all processors
C
      INCLUDE 'SIZE'
      INCLUDE 'INPUT'
C
C     Default if no data is read No Objects
C
      NOBJ=0

      READ(9,*,ERR=200,END=200)
      READ(9,*,ERR=200,END=200) NOBJ
C
      IF(NOBJ.GT.MAXOBJ)THEN
         write(6,*) nid,'ERROR, too many objects:',nobj,maxobj
         call exitt(1)
      ENDIF
C
      DO 10 IOBJ = 1,NOBJ
         READ(9,*,ERR=200,END=200) NMEMBER(IOBJ)
         IF(NMEMBER(IOBJ).GT.MAXMBR)THEN
            PRINT*,'ERROR: Too many members in object ',IOBJ
            call exitt(1)
         ENDIF
         DO 5 MEMBER=1,NMEMBER(IOBJ)
            READ(9,*,ERR=200,END=200) OBJECT(IOBJ,MEMBER,1),
     $                                OBJECT(IOBJ,MEMBER,2)
    5    CONTINUE
   10 CONTINUE
      if (nid.eq.0) write(6,*) nobj,' objects found,'
     $                             ,(nmember(k),k=1,nobj)
C
      RETURN
C
C     Error handling:  For old versions, default to no objects
C
  200 CONTINUE
      NOBJ=0
C
      RETURN
      END
c-----------------------------------------------------------------------
      subroutine readat
C
C     Read in data from preprocessor input file (.rea)
C
      INCLUDE 'SIZE'
      INCLUDE 'INPUT'
      INCLUDE 'PARALLEL'
      INCLUDE 'ZPER'

      common /nekmpi/ nid_,np_,nekcomm,nekgroup,nekreal

      logical ifbswap, ifre2
      character*132 string
      real*8 etime_tmp
      integer idum(3*numsts+3)

C     Test timer accuracy
      edif = 0.0
      do i = 1,10
         e1 = dclock()
         e2 = dclock()
         edif = edif + e2-e1
      enddo
      edif = edif/10.
      if (nid.eq.0) write(6,'(A,1pE15.7,A,/)')
     &              ' timer accuracy: ', edif, ' sec'

      etime_tmp = dclock()

C     Open .rea file
      if (nid.eq.0) then
        write(6,*) 'read .rea file'
        OPEN (UNIT=9,FILE=REAFLE,STATUS='OLD')
      endif

C     Read parameters and logical flags
      call rdparam2

C     Read mesh info
      if (nid.eq.0) then
         read(9,*)              ! xfac,yfac,xzero,yzero
         read(9,*)              ! dummy
         read(9,*) nelgs,ndim,nelgv
         nelgt = abs(nelgs)
      endif

      call bcast(nelgs,ISIZE)
      call bcast(ndim ,ISIZE)
      call bcast(nelgv,ISIZE)
      call bcast(nelgt,ISIZE)
      call bcast(h5mfle,132)

      ifre2 =.false.
      if (nelgs.lt.0) ifre2 = .true.     ! use new .re2 reader

      ifgtp =.false.
      if (ndim.lt.0)  ifgtp = .true.     ! domain is a global tensor product

      call ifoption (ifgtp)
      call ifoption (ifre2)

      if (ifre2) call open_bin_file(ifbswap) ! rank0 will open and read
      if (nid.eq.0) then
         write(6,12) 'nelgt/nelgv/lelt:',nelgt,nelgv,lelt
         write(6,12) 'lx1  /lx2  /lx3 :',lx1,lx2,lx3
 12      format(1X,A,4I9,/,/)
      endif

      call chk_nel              ! make certain sufficient array sizes
      if (.not.ifgtp) call mapelpr ! read .map file, est. gllnid, etc.

      if (nid.eq.0) write(6,*) 'gfdm/ifgtp/ifre2',ifgfdm,ifgtp,ifre2

      if (ifre2) then
         call bin_rd1(ifbswap)  ! rank0 will read mesh data + distribute
      else
         maxrd = 32             ! max # procs to read at once
         mread = (np-1)/maxrd+1 ! mod param
         iread = 0              ! mod param
         x = 0

         t0 = dclock()
         if (nid.eq.0)  write(6,*)  'start reading mesh'
         do i=0,np-1,maxrd
            call nekgsync()
            if (mod(nid,mread).eq.iread) then
               if(nid.ne.0) then
                  open(UNIT=9,FILE=REAFLE,STATUS='OLD')
                  call cscan(string,'MESH DATA',9)
                  read(9,*) string
               endif
               if (ifgtp) then
                  call genbox2
               else
                  call rdmesh2
                  call rdcurve2 ! Curved side data
                  call rdbdry2  ! Boundary Conditions
               endif
               if(nid.ne.0) close(unit=9)
            endif
            iread = iread + 1
         enddo
         if (nid.eq.0)  write(6,2)  dclock()-t0
 2       format(' read mesh time::',1pe11.4,' seconds ')

      endif

      call nekgsync()

C     End of input data, close read file.
      IF(NID.EQ.0) THEN
        CLOSE(UNIT=9)
        write(6,'(A,g13.5,A,/)')  ' done :: close .rea file ',
     &                            dclock()-etime_tmp,' sec'
      ENDIF

c     This is not an excellent place for this check, but will
c     suffice for now.   5/6/10
c     if (ifchar.and.(nelgv.ne.nelgt)) call exitti(
c    $ 'ABORT: IFCHAR curr. not supported w/ conj. ht transfer$',nelgv)

      return
      END

c-----------------------------------------------------------------------
      subroutine rdparam2
C
C     .Read in parameters supplied by preprocessor and
C      (eventually) echo check.
C
C     .Broadcast run parameters to all processors
C
      INCLUDE 'SIZE'
      INCLUDE 'INPUT'
      INCLUDE 'PARALLEL'
      INCLUDE 'CTIMER'
      INCLUDE 'EMWAVE'
      INCLUDE 'ZPER'

      character*132 string(100)
c     This shouldn't exist! The `ifnm` switch isn't used any more, but
c     to remove it properly we'll have to change all the rea files.
      logical ifnm

      VNEKTON = 3 ! dummy not really used anymore

      IF(NID.EQ.0) THEN
        READ(9,*,ERR=400)
        READ(9,*,ERR=400)
        READ(9,*,ERR=400) NDIM
        READ(9,*,ERR=400) NPARAM
        DO 20 I=1,NPARAM
           READ(9,*,ERR=400) PARAM(I)
   20   CONTINUE
      ENDIF

      call bcast(NDIM  ,ISIZE)
      call bcast(NPARAM,ISIZE)
      call bcast(PARAM ,200*WDSIZE)

      NPSCAL = 0 !originally: INT(PARAM(23)), but zero default for CEM.          
      nfield = 1
      if (param(8).gt.0) then
          nfield = param(8)
          NPSCAL = nfield
      endif
      NPSCL1= NPSCAL+1
      NPSCL2= NPSCAL+2

      if(nid.eq.0) write(6,*) 'NPSCAL/nfield/ldimt',NPSCAL,nfield,ldimt

      IF (nfield.GT.LDIMT) THEN
         if(nid.eq.0) then
           WRITE(6,21) LDIMT,nfield
   21      FORMAT(//,2X,'Error: This NEKTON Solver has been compiled'
     $             /,2X,'       for',I3,' passive scalars.  This run'
     $             /,2X,'       requires that LDIMT be set to',I3,'.')
         endif
         call exitt(1)
      ENDIF

      nelx   = abs(param(116))   ! check for global tensor-product structure
      nely   = abs(param(117))
      nelz   = abs(param(118))
      n_o    = 0

      if (n_o.eq.0) then
         ifzper=.false.
         ifgfdm=.false.
         if (nelz.gt.0) ifzper=.true.
         if (nelx.gt.0) ifgfdm=.true.
         if (nelx.gt.0) ifzper=.false.
      endif


      IF(NDIM.NE.LDIM)THEN
         IF(NID.EQ.0) THEN
           WRITE(6,10) LDIM,NDIM
   10      FORMAT(//,2X,'ERROR: This NEKTON Solver has been compiled'
     $             /,2X,'       for spatial dimension equal to',I2,'.'
     $             /,2X,'       The data file has dimension',I2,'.')
         ENDIF
         call exitt(1)
      ENDIF
      IF (NDIM.EQ.3) IF3D=.TRUE.
      IF (NDIM.NE.3) IF3D=.FALSE.


      IF(NID.EQ.0) THEN
        READ(9,*,ERR=400) NSKIP
        IF (NSKIP.GT.0 .AND. NPSCAL.GT.0) THEN
           READ(9,*,ERR=400) !(CPFLD(I,1),I=3,NPSCL2)
           IF(NPSCL2.LT.9)READ(9,*)
           READ(9,*,ERR=400) !(CPFLD(I,2),I=3,NPSCL2)
           IF(NPSCL2.LT.9)READ(9,*)
           do i=3,npscl2
c             if (cpfld(i,1).lt.0) cpfld(i,1) = -1./cpfld(i,1)
c             if (cpfld(i,2).lt.0) cpfld(i,2) = -1./cpfld(i,2)
           enddo
        ELSE
           DO 25 I=1,NSKIP
              READ(9,*,ERR=500)
   25         CONTINUE
        ENDIF
      ENDIF
      call bcast(cpfld,WDSIZE*LDIMT1*3)

      IF(NID.EQ.0) THEN
        READ(9,*,ERR=500) NLOGIC
        IF(NLOGIC.GT.100) THEN
          write(6,*) 'ABORT: Too many logical switches', NLOGIC
          call exitt(1)
        ENDIF
        READ(9,'(A132)',ERR=500) (string(i),i=1,NLOGIC)
      ENDIF
      call bcast(NLOGIC,ISIZE)
      call bcast(string,100*132*CSIZE)

      do i = 1,NLOGIC
         call capit(string(i),132)

         if     (indx1(string(i),'IFFLOW' ,6).gt.0) then
              read(string(i),*,ERR=490) IFFLOW
         elseif (indx1(string(i),'IFHEAT' ,6).gt.0) then
              read(string(i),*,ERR=490) IFHEAT
         elseif (indx1(string(i),'IFTRAN' ,6).gt.0) then
              read(string(i),*,ERR=490) IFTRAN
         elseif (indx1(string(i),'IFSRC' ,5).gt.0) then
              read(string(i),*,ERR=490) IFSRC
         elseif (indx1(string(i),'IFCENTRAL'  ,9).gt.0) then
              read(string(i),*,ERR=490) IFCENTRAL
         elseif (indx1(string(i),'IFUPWIND'  ,8).gt.0) then
              read(string(i),*,ERR=490) IFUPWIND
         elseif (indx1(string(i),'IFTM'  ,4).gt.0) then
              read(string(i),*,ERR=490) IFTM
         elseif (indx1(string(i),'IFTE'  ,4).gt.0) then
              read(string(i),*,ERR=490) IFTE
         elseif (indx1(string(i),'IFDEALIAS'  ,9).gt.0) then
              read(string(i),*,ERR=490) IFDEALIAS
         elseif (indx1(string(i),'IFRK4'  ,5).gt.0) then
              read(string(i),*,ERR=490) IFRK4
         elseif (indx1(string(i),'IFEXP'  ,5).gt.0) then
              read(string(i),*,ERR=490) IFEXP
         elseif (indx1(string(i),'IFEIG'  ,5).gt.0) then
              read(string(i),*,ERR=490) IFEIG
         elseif (indx1(string(i),'IFNM'  ,4).gt.0) then
              read(string(i),*,ERR=490) IFNM
         else
              if(nid.eq.0) then
                write(6,'(1X,2A)') 'ABORT: Unkown logical flag',string
                write(6,'(30(A,/))')
     &           ' Available logical flags:',
     &           '   IFSRC '   ,
     &           '   IFCENTRAL',
     &           '   IFUPWIND' ,
     &           '   IFTM    ' ,
     &           '   IFTE    ' ,
     &           '   IFDEALIA' ,
     &           '   IFRK4   ' ,
     &           '   IFEXP   ' ,
     &           '   IFEIG   ' ,
     &           '   IFNM    '
              endif
              call exitt(1)
         endif
 490  continue

      enddo

c     IF (NPSCL1.GT.LDIMT .AND. IFMHD) THEN
c        if(nid.eq.0) then
c          WRITE(6,22) LDIMT,NPSCL1
c  22      FORMAT(/s,2X,'Error: This NEKTON Solver has been compiled'
c    $             /,2X,'       for',I3,' passive scalars.  A MHD run'
c    $             /,2X,'       requires that LDIMT be set to',I3,'.')
c        endif
c        call exitt
c     ENDIF

      return

  400 CONTINUE

      if(nid.eq.0) WRITE(6,401)
  401 FORMAT(2X,'ERROR READING PARAMETER DATA'
     $    ,/,2X,'ABORTING IN ROUTINE RDPARAM.')
      call exitt(1)

  500 CONTINUE
      if(nid.eq.0) WRITE(6,501)
  501 FORMAT(2X,'ERROR READING LOGICAL DATA'
     $    ,/,2X,'ABORTING IN ROUTINE RDPARAM.')
      call exitt(1)
C
      return
      end

c-----------------------------------------------------------------------
      subroutine rdmesh2
C
C     .Read number of elements
C
C     .Construct sequential element-processor partition according
C      to number of elements and processors
C
C     .Selectively read mesh (defined by element vertices, and group
C     numbers)
C      on each processor
C
      include 'SIZE'
      include 'INPUT'
      include 'PARALLEL'
      character*1 adum
      real    dum(4)


c     Read elemental mesh data, formatted
      iffmtin = .true.

      call chk_nel

      NSIDES=NDIM*2
      DO 40 IEG=1,NELGT
         IF (GLLNID(IEG).EQ.NID) THEN
            IEL=GLLEL(IEG)

            igroup(iel) = 0
            read(9,30,err=31,end=600) igroup(iel)
   30       format(43x,i5)
c           read(9,*,err=31,end=600) adum
   31       continue

C           Read Corner data
            IF(NDIM.EQ.2)THEN
               READ(9,*,ERR=500,END=600) (XC(IC,IEL),IC=1,4)
               READ(9,*,ERR=500,END=600) (YC(IC,IEL),IC=1,4)
                              call rzero (zc(1 ,iel)     ,4)
            ELSE IF(NDIM.EQ.3)THEN
               READ(9,*,ERR=500,END=600) (XC(IC,IEL),IC=1,4)
               READ(9,*,ERR=500,END=600) (YC(IC,IEL),IC=1,4)
               READ(9,*,ERR=500,END=600) (ZC(IC,IEL),IC=1,4)
               READ(9,*,ERR=500,END=600) (XC(IC,IEL),IC=5,8)
               READ(9,*,ERR=500,END=600) (YC(IC,IEL),IC=5,8)
               READ(9,*,ERR=500,END=600) (ZC(IC,IEL),IC=5,8)
            ENDIF
         ELSE
C           Skip over this data for element NOT on this processor
            READ(9,41,ERR=500,END=600) ADUM
C           Read Corner data
            IF(NDIM.EQ.2)THEN
               READ(9,41,ERR=500,END=600) ADUM
               READ(9,41,ERR=500,END=600) ADUM
            ELSE IF(NDIM.EQ.3)THEN
               READ(9,41,ERR=500,END=600) ADUM
               READ(9,41,ERR=500,END=600) ADUM
               READ(9,41,ERR=500,END=600) ADUM
               READ(9,41,ERR=500,END=600) ADUM
               READ(9,41,ERR=500,END=600) ADUM
               READ(9,41,ERR=500,END=600) ADUM
            ENDIF
         ENDIF
   40 CONTINUE
   41 FORMAT(A1)
C
C     End of mesh read.
C
      return
C
C     Error handling:
C
  400 CONTINUE
      if(nid.eq.0) WRITE(6,401)
  401 FORMAT(2X,'ERROR READING SCALE FACTORS, CHECK READ FILE'
     $    ,/,2X,'ABORTING IN ROUTINE RDMESH.')
      call exitt(1)

  500 CONTINUE
      if(nid.eq.0) WRITE(6,501) IEG
  501 FORMAT(2X,'ERROR READING MESH DATA NEAR ELEMENT',I7
     $    ,/,2X,'ABORTING IN ROUTINE RDMESH.')
      call exitt(1)

  600 CONTINUE
      if(nid.eq.0) WRITE(6,601) IEG
  601 FORMAT(2X,'ERROR 2 READING MESH DATA NEAR ELEMENT',I7
     $    ,/,2X,'ABORTING IN ROUTINE RDMESH.')
      call exitt(1)

      return
      end

c-----------------------------------------------------------------------
      subroutine rdcurve
C
C     .Read curve side data
C
C     .Disperse curve side data to all processors according
C      to sequential partition scheme
C
C
      INCLUDE 'SIZE'
      INCLUDE 'INPUT'
      INCLUDE 'PARALLEL'
      CHARACTER*1 ANS
C
C
      IFFMTIN = .true.
      IF (IFFMTIN) THEN
C
C     Read formatted curve side data
C
      READ(9,*)
      READ(9,*)NCURVE
      CALL RZERO(CURVE ,48*LELT)
      CALL BLANK(CCURVE, 8*LELT)
      IF (NCURVE.GT.0) THEN
         DO 50 ICURVE=1,NCURVE
            IF (NELGT.LT.1000) THEN
               READ(9,60,ERR=500,END=500) IEDG,IEG,R1,R2,R3,R4,R5,ANS
            ELSEIF (NELGT.LT.1000000) THEN
               READ(9,61,ERR=500,END=500) IEDG,IEG,R1,R2,R3,R4,R5,ANS
            ELSE
               IF(NID.EQ.0) write(6,*)
     &           'ABORT: no support for >1M elements for ASCII .rea!'
               call exitt(1)
            ENDIF
   60       FORMAT(I3,I3 ,5G14.6,1X,A1)
   61       FORMAT(I2,I6 ,5G14.6,1X,A1)
   62       FORMAT(I2,I10,5G14.6,1X,A1)

            IF (GLLNID(IEG).EQ.NID) THEN
               IEL=GLLEL(IEG)
               CURVE (1,IEDG,IEL)=R1
               CURVE (2,IEDG,IEL)=R2
               CURVE (3,IEDG,IEL)=R3
               CURVE (4,IEDG,IEL)=R4
               CURVE (5,IEDG,IEL)=R5
               CCURVE(  IEDG,IEL)=ANS
            ENDIF
   50    CONTINUE
      ENDIF
      return
C
C     Error handling:
C
  500 CONTINUE
      if(nid.eq.0) WRITE(6,501)
  501 FORMAT(2X,'ERROR READING CURVE SIDE DATA'
     $    ,/,2X,'ABORTING IN ROUTINE RDCURVE.')
      call exitt(1)
      return
C
      ELSE

C
C     Read unformatted curve side data
C
      READ(8) NCURVE
      CALL RZERO(CURVE ,48*LELT)
      CALL BLANK(CCURVE, 8*LELT)
      IF (NCURVE.GT.0) THEN
         DO 1050 ICURVE=1,NCURVE
            READ(8,ERR=1500,END=1500) IEDG,IEG,R1,R2,R3,R4,R5,ANS
            IF (GLLNID(IEG).EQ.NID) THEN
               IEL=GLLEL(IEG)
               CURVE (1,IEDG,IEL)=R1
               CURVE (2,IEDG,IEL)=R2
               CURVE (3,IEDG,IEL)=R3
               CURVE (4,IEDG,IEL)=R4
               CURVE (5,IEDG,IEL)=R5
               CCURVE(  IEDG,IEL)=ANS
            ENDIF
 1050    CONTINUE
      ENDIF
      return
C
C     Error handling:
C
 1500 CONTINUE
      if(nid.eq.0) WRITE(6,1501)
 1501 FORMAT(2X,'ERROR READING unformatted CURVE SIDE DATA'
     $    ,/,2X,'ABORTING IN ROUTINE RDCURVE.')
      call exitt(1)
C
      return
      ENDIF
      END
c-----------------------------------------------------------------------
      subroutine rdbdry2
C
C     .Read Boundary Conditions (and connectivity data)
C
C     .Disperse boundary condition data to all processors
C      according to sequential partition scheme
C
      INCLUDE 'SIZE'
      INCLUDE 'INPUT'
      INCLUDE 'PARALLEL'
      INCLUDE 'SCRCT'
      CHARACTER CBC1*1,CBC3*3,CHTEMP*1,CHTMP3*3
      EQUIVALENCE (CHTEMP,CHTMP3)
      character*132 string
C
C     Set up TEMPORARY value for NFIELD - NFLDT
C
      ibcs   = 1
      nfldt  = nfield
      nbcs   = nfldt
      nsides = 2*ndim
C
C     Read boundary conditions for all fields
C
      LCBC=18*LELT*(LDIMT1 + 1)
      LRBC=30*LELT*(LDIMT1 + 1)
      CALL RZERO(BC ,LRBC)
      CALL BLANK(CBC,LCBC)
C
      if (nid.eq.0) write(6,*) 'rdbdry2: ifheat/ifmhd/ifflow=',
     $                          ifheat,ifmhd,ifflow
      if (nid.eq.0) write(6,*) 'rdbdry2: nfield/nfldt/nbcs/ibcs=',
     $                          nfield,nfldt,nbcs,ibcs
C-----------------------------------------------------------------
C  Formatted Reads
C-----------------------------------------------------------------
C

      IF (IFFMTIN) THEN
C
      READ(9,*,ERR=500,END=500)  !   ***** BOUNDARY CONDITIONS *****
      ibcnew = 1
      DO 100 IFLD=ibcnew,NBCS  !     DO 100 IFIELD=IBCS,NBCS

        NEL=NELGT
c       if (.not.iftmsh(ifld)) nel = nelgv
C       Fluid and/or thermal
        read(9,81) string        !  ***** FLUID   BOUNDARY CONDITIONS *****
        call capit(string,132)

        if1 = indx1(string,'NO ',3)

c       write(6,*) if1,' if NO.  quit.',ifld,ibcs,nbcs
c       write(6,*) ifld,iftmsh(ifld),nel,' iftmsh'
c       call exitt

        if (indx1(string,'NO ',3).eq.0) then ! we have acitve bc info

         IF(VNEKTON .LE. 2.52) NBCREA = 3
         IF(VNEKTON .GE. 2.55) NBCREA = 5
C
         DO 80 IEG=1,NEL
         DO 80 ISIDE=1,NSIDES
            IF (GLLNID(IEG).EQ.NID) THEN
               IEL=GLLEL(IEG)
               IF (NELGT.LT.1000) THEN
                  READ(9,50,ERR=500,END=500)
     $            CHTEMP,
     $            CBC(ISIDE,IEL,IFLD),ID1,ID2,
     $            (BC(II,ISIDE,IEL,IFLD),II=1,NBCREA)
   50             FORMAT(A1,A3,2I3,5G14.6)
               ELSEIF (NELGT.LT.100000) THEN
                  READ(9,51,ERR=500,END=500)
     $            CHTEMP,
     $            CBC(ISIDE,IEL,IFLD),ID1,ID2,
     $            (BC(II,ISIDE,IEL,IFLD),II=1,NBCREA)
   51             FORMAT(A1,A3,I5,I1,5G14.6)
               ELSEIF (NELGT.LT.1000000) THEN
                  READ(9,52,ERR=500,END=500)
     $            CHTEMP,
     $            CBC(ISIDE,IEL,IFLD),ID1,
     $            (BC(II,ISIDE,IEL,IFLD),II=1,NBCREA)
   52             FORMAT(A1,A3,I6,5G14.6)
               ELSE
                  IF(NID.EQ.0) write(6,*)
     &              'ABORT: no support for >1M elements for ASCII .rea!'
                  call exitt(1)
               ENDIF
C              Mesh B.C.'s in 1st column of 1st field
               IF (CHTEMP.NE.' ') CBC(ISIDE,IEL,0)(1:1)= CHTEMP
C              check for fortran function as denoted by lower case bc's:
               CBC1=CBC(ISIDE,IEL,IFLD)
               CBC3=CBC(ISIDE,IEL,IFLD)
               ICBC1=ICHAR(CBC1)
               IF (ICBC1.GE.97.AND.ICBC1.LE.122) THEN
                  IF(CBC3(3:3).NE.'i')NLINES=BC(1,ISIDE,IEL,IFLD)
                  IF(CBC3(3:3).EQ.'i')NLINES=BC(4,ISIDE,IEL,IFLD)
                  DO 60 I=1,NLINES
   60             READ(9,*,ERR=500,END=500)
               ENDIF
            ELSE
               READ(9,*,ERR=500,END=500)   cbc1  ! dummy read, pff 4/28/05
            ENDIF
   80    CONTINUE
        endif
   81   format(a132)
  100 CONTINUE

C     END OF BC READ
C
C     Check for dummy line:  "NO THERMAL B.C.'S"
      IF (NFLDT.EQ.1) READ(9,*,ERR=500,END=500)
C
      return
C
C     Error handling:
C
  500 CONTINUE
      if(nid.eq.0) WRITE(6,501) IFLD,IEG
  501 FORMAT(2X,'ERROR READING BOUNDARY CONDITIONS FOR FIELD',I4,I6
     $    ,/,2X,'ABORTING IN ROUTINE RDBDRY.')
      call exitt(1)
      return
C
C
      ELSE
C
C-----------------------------------------------------------------
C  UNformatted Reads
C-----------------------------------------------------------------
C
C
c     READ(8,ERR=500,END=500)
      DO 1100 IFLD=IBCS,NBCS
         NEL=NELGT
C        Fluid and/or thermal
         NBCREA = 5
C
         DO 1080 IEG=1,NEL
         DO 1080 ISIDE=1,NSIDES
            IF (GLLNID(IEG).EQ.NID) THEN
               IEL=GLLEL(IEG)
               READ(8,ERR=1500,END=1500)
     $         CHTMP3,
     $         CBC(ISIDE,IEL,IFLD),ID1,ID2,
     $         (BC(II,ISIDE,IEL,IFLD),II=1,NBCREA)

C              Mesh B.C.'s in 1st column of 1st field
C              check for fortran function as denoted by lower case bc's:
               IF (CHTEMP.NE.' ') CBC(ISIDE,IEL,0)(1:1)= CHTEMP
c    $         CBCS(ISIDE,IEL),ID1,ID2,(BCS(II,ISIDE,IEL),II=1,NBCREA)
c    $         CBC(ISIDE,IEL,IFLD),ID1,ID2,
            ELSE
               IEL=1
               READ(8,ERR=1500,END=1500) CHTMP3,
     $         CBCS(ISIDE,IEL),ID1,ID2,(BCS(II,ISIDE,IEL),II=1,NBCREA)
C              check for fortran function as denoted by lower case bc's:
            ENDIF
 1080    CONTINUE
 1100 CONTINUE
C
C     END OF BC READ
C
      return
C
C     Error handling:
C
 1500 CONTINUE
      if(nid.eq.0) WRITE(6,1501) IFLD,IEG
 1501 FORMAT(2X,'ERROR READING BOUNDARY CONDITIONS FOR FIELD',I4,I6
     $    ,/,2X,'(unformatted) ABORTING IN ROUTINE RDBDRY.')
      call exitt(1)
      ENDIF
C
      return
      END


c-----------------------------------------------------------------------
      subroutine rdicdf2
C
C     .Read Initial Conditions / Drive Force
C
C     .Broadcast ICFILE to all processors
C
      INCLUDE 'SIZE'
      INCLUDE 'INPUT'
      INCLUDE 'PARALLEL'

      CHARACTER*132 LINE
      LOGICAL      IFGTIL

      IF(NID.EQ.0) THEN
      CALL BLANK(INITC,15*132)
      READ(9,80,ERR=200,END=200) LINE
      IF (INDX1(LINE,'RESTART',7).NE.0) THEN
         IF (.NOT.IFGTIL(NSKIP,LINE)) GOTO 200
c        READ(LINE,*,ERR=200,END=200) NSKIP
         DO 50 I=1,NSKIP
            READ(9,80,ERR=200,END=200) INITC(I)
   50    CONTINUE
         READ(9,80,ERR=200,END=200) LINE
      ENDIF
   80 FORMAT(A80)
      IF (.NOT.IFGTIL(NSKIP,LINE)) GOTO 200
c     READ(LINE,*,ERR=200,END=200)NSKIP
      DO 100 I=1,NSKIP
         READ(9,80,ERR=200,END=200) LINE
  100 CONTINUE
C     Read drive force data
      READ(9,*,ERR=200,END=200)
      READ(9,*,ERR=200,END=200) NSKIP
      DO 110 I=1,NSKIP
        READ(9,80,ERR=200,END=200) LINE
  110 CONTINUE

      ENDIF

      CALL BCAST(INITC,15*132*CSIZE)

      return
C
C     Error handling:
C
  200 CONTINUE
      if(nid.eq.0) WRITE(6,201)
  201 FORMAT(2X,'ERROR READING INITIAL CONDITION/DRIVE FORCE DATA'
     $    ,/,2X,'ABORTING IN ROUTINE RDICDF.')
      call exitt(1)
C
      return
      END
c-----------------------------------------------------------------------
      SUBROUTINE VRDSMSH
C=====================================================================
C     Verify that mesh and dssum are properly defined by performing
C        a direct stiffness operation on the X,Y and Z coordinates.
C     Note that periodic faces are not checked here.
C=====================================================================
C
      INCLUDE 'SIZE'
      INCLUDE 'TOTAL'
      COMMON /SCRNS/ TA(LX1,LY1,LZ1,LELT),TB(LX1,LY1,LZ1,LELT)
     $           ,QMASK(LX1,LY1,LZ1,LELT),tmp(2)
      CHARACTER*3 CB
C
      IERR      = 0
      EPS       = 1.0e-04
      IFLD    = 1
      NXYZ1     = NX1*NY1*NZ1
      NTOT      = NX1*NY1*NZ1*NELT
      NFACES    = 2*NDIM
C
C     First check - use 1/Multiplicity
C
      IF (IFHEAT) THEN
         CALL COPY(TA,TMULT,NTOT)
      ELSE
         CALL COPY(TA,VMULT,NTOT)
      ENDIF

      CALL DSSUM(TA,NX1,NY1,NZ1)
c
c     write(6,1)
c    $(nid,'taaf',lglel(ie,node),(ta(k,1,1,ie),k=1,nx1*ny1),ie=1,nelt)
c
      CALL RONE (TB,NTOT)
      CALL SUB2 (TB,TA,NTOT)

      DO 1000 IE=1,NELT
      IEG=LGLEL(IE)
      DO 1000 IZ=1,NZ1
      DO 1000 IY=1,NY1
      DO 1000 IX=1,NX1
         IF (ABS(TB(IX,IY,IZ,IE)).GT.EPS ) THEN
            WRITE(6,1005) IX,IY,IZ,IEG
     $      ,XM1(IX,IY,IZ,IE),YM1(IX,IY,IZ,IE),ZM1(IX,IY,IZ,IE)
     $      ,TA(IX,IY,IZ,IE),eps
c           WRITE(7,1005) IX,IY,IZ,IEG
c    $      ,XM1(IX,IY,IZ,IE),TB(IX,IY,IZ,IE),TA(IX,IY,IZ,IE)
c    $      ,QMASK(IX,IY,IZ,IE)
 1005       FORMAT(2X,'WARNING: DSSUM problem at:',/
     $            ,2X,'I,J,K,IE:',4I5,/
     $            ,2X,'Near X =',3G16.8,', d:',2G16.8)
            IERR=4
         ENDIF
 1000 CONTINUE
C
C     Set up QMASK quickly to annihilate checks on periodic bc's
C
      CALL RONE(QMASK,NTOT)
      DO 100 IEL=1,NELT
      DO 100 IFACE=1,NFACES
         CB =CBC(IFACE,IEL,IFLD)
         IF (CB.EQ.'P  ')
     $         CALL FACEV(QMASK,IEL,IFACE,0.0,NX1,NY1,NZ1)
  100 CONTINUE
      CALL DSOP(QMASK,'MUL',NX1,NY1,NZ1)
C
C     X-component
C
      CALL COPY(TA,XM1,NTOT)
      CALL COPY(TB,XM1,NTOT)
      CALL DSOP(TA,'MIN',NX1,NY1,NZ1)
      CALL DSOP(TB,'MAX',NX1,NY1,NZ1)
      CALL SUB2(TA,XM1,NTOT)
      CALL SUB2(TB,XM1,NTOT)
      CALL COL2(TA,QMASK,NTOT)
      CALL COL2(TB,QMASK,NTOT)
      DO 1100 IE=1,NELT
         XSCMAX = VLMAX(XM1(1,1,1,IE),NXYZ1)
         XSCMIN = VLMIN(XM1(1,1,1,IE),NXYZ1)
         SCAL1=ABS(XSCMAX-XSCMIN)
         SCAL2=ABS(XSCMAX)
         SCAL3=ABS(XSCMIN)
         SCAL1=MAX(SCAL1,SCAL2)
         SCAL1=MAX(SCAL1,SCAL3)
         XSCALE = 1./SCAL1
         IEG=LGLEL(IE)
         DO 1100 IZ=1,NZ1
         DO 1100 IY=1,NY1
         DO 1100 IX=1,NX1
         IF (ABS(TA(IX,IY,IZ,IE)*XSCALE).GT.EPS .OR.
     $       ABS(TB(IX,IY,IZ,IE)*XSCALE).GT.EPS ) THEN
            WRITE(6,1105) IX,IY,IZ,IEG
     $      ,XM1(IX,IY,IZ,IE),YM1(IX,IY,IZ,IE),ZM1(IX,IY,IZ,IE)
     $      ,TB(IX,IY,IZ,IE),TA(IX,IY,IZ,IE),xscale
 1105       FORMAT(1X,'WARNING: Element mesh mismatch at:',/
     $            ,1X,'I,J,K,IE:',4I5,/
     $            ,1X,'Near X =',3G16.8,', d:',3G16.8)
            IERR=1
         ENDIF
 1100 CONTINUE
C
C     Y-component
C
      CALL COPY(TA,YM1,NTOT)
      CALL COPY(TB,YM1,NTOT)
      CALL DSOP(TA,'MIN',NX1,NY1,NZ1)
      CALL DSOP(TB,'MAX',NX1,NY1,NZ1)
      CALL SUB2(TA,YM1,NTOT)
      CALL SUB2(TB,YM1,NTOT)
      CALL COL2(TA,QMASK,NTOT)
      CALL COL2(TB,QMASK,NTOT)
      DO 1200 IE=1,NELT
         YSCMAX = VLMAX(YM1(1,1,1,IE),NXYZ1)
         YSCMIN = VLMIN(YM1(1,1,1,IE),NXYZ1)
         SCAL1=ABS(YSCMAX-YSCMIN)
         SCAL2=ABS(YSCMAX)
         SCAL3=ABS(YSCMIN)
         SCAL1=MAX(SCAL1,SCAL2)
         SCAL1=MAX(SCAL1,SCAL3)
         YSCALE = 1./SCAL1
         IEG=LGLEL(IE)
         DO 1200 IZ=1,NZ1
         DO 1200 IY=1,NY1
         DO 1200 IX=1,NX1
         IF (ABS(TA(IX,IY,IZ,IE)*YSCALE).GT.EPS .OR.
     $       ABS(TB(IX,IY,IZ,IE)*YSCALE).GT.EPS ) THEN
            WRITE(6,1205) IX,IY,IZ,IEG
     $      ,XM1(IX,IY,IZ,IE),YM1(IX,IY,IZ,IE),ZM1(IX,IY,IZ,IE)
     $      ,TB(IX,IY,IZ,IE),TA(IX,IY,IZ,IE),yscale
 1205       FORMAT(1X,'WARNING: Element mesh mismatch at:',/
     $            ,1X,'I,J,K,IE:',4I5,/
     $            ,1X,'Near Y =',3G16.8,', d:',3G16.8)
            IERR=2
         ENDIF
 1200 CONTINUE
C
C     Z-component
C
      IF (ldim.eq.3) THEN
       CALL COPY(TA,ZM1,NTOT)
       CALL COPY(TB,ZM1,NTOT)
       CALL DSOP(TA,'MIN',NX1,NY1,NZ1)
       CALL DSOP(TB,'MAX',NX1,NY1,NZ1)
       CALL SUB2(TA,ZM1,NTOT)
       CALL SUB2(TB,ZM1,NTOT)
       CALL COL2(TA,QMASK,NTOT)
       CALL COL2(TB,QMASK,NTOT)
       DO 1300 IE=1,NELT
          ZSCMAX = VLMAX(ZM1(1,1,1,IE),NXYZ1)
          ZSCMIN = VLMIN(ZM1(1,1,1,IE),NXYZ1)
          SCAL1=ABS(ZSCMAX-ZSCMIN)
          SCAL2=ABS(ZSCMAX)
          SCAL3=ABS(ZSCMIN)
          SCAL1=MAX(SCAL1,SCAL2)
          SCAL1=MAX(SCAL1,SCAL3)
          ZSCALE = 1./SCAL1
          IEG=LGLEL(IE)
          DO 1300 IZ=1,NZ1
          DO 1300 IY=1,NY1
          DO 1300 IX=1,NX1
          IF (ABS(TA(IX,IY,IZ,IE)*ZSCALE).GT.EPS .OR.
     $        ABS(TB(IX,IY,IZ,IE)*ZSCALE).GT.EPS ) THEN
           WRITE(6,1305) IX,IY,IZ,IEG
     $      ,XM1(IX,IY,IZ,IE),YM1(IX,IY,IZ,IE),ZM1(IX,IY,IZ,IE)
     $      ,TB(IX,IY,IZ,IE),TA(IX,IY,IZ,IE),zscale
 1305       FORMAT(1X,'WARNING: Element mesh mismatch at:',/
     $            ,1X,'I,J,K,IE:',4I5,/
     $            ,1X,'Near Z =',3G16.8,', d:',3G16.8)
            IERR=3
          ENDIF
 1300  CONTINUE
      ENDIF
C
      IF (IERR.gt.0) THEN
         WRITE(6,1400)
 1400    FORMAT
     $   ('  Mesh consistency check failed.  EXITING in VRDSMSH.')
      ENDIF
C
      tmp(1)=ierr
      CALL GOP(tmp,tmp(2),'M  ',1)
      IF (tmp(1).ge.4.0) THEN
         call exitt(1)
      ENDIF
C
      IF (NID.EQ.0) WRITE(6,1500)
 1500 FORMAT('  Mesh consistency check, OK.')
      RETURN
      END
      SUBROUTINE ROTAT2(XYZ,ANGLE,N)
C
C     Rotate NPTS through ANGLE (in two directions if ldim = 3).
C
      INCLUDE 'SIZE'
      INCLUDE 'INPUT'
      DIMENSION XYZ(3,1)
      COMMON /CTMP0/ RMTRX(3,3),RX(3,3),RZ(3,3),XYZN(3,10)
C
      SINA=SIN(ANGLE)
      COSA=COS(ANGLE)
      CALL RZERO(RX,9)
      CALL RZERO(RZ,9)
      RX(1,1)=COSA
      RX(2,2)=COSA
      RX(1,2)=SINA
      RX(2,1)=-SINA
      RX(3,3)=1.0
      IF (ldim.eq.3) THEN
         RZ(1,1)=COSA
         RZ(3,3)=COSA
         RZ(1,3)=SINA
         RZ(3,1)=-SINA
         RZ(2,2)=1.0
      ELSE
         RZ(1,1)=1.0
         RZ(2,2)=1.0
         RZ(3,3)=1.0
      ENDIF
      CALL MXM(RX,3,RZ,3,RMTRX,3)
C
C     Strip mine mxms in chunks of 10:
      DO 100 I=1,N-10,10
         CALL MXM(RMTRX,3,XYZ(1,I),3,XYZN,10)
         CALL COPY(XYZ(1,I),XYZN,30)
  100 CONTINUE
      N10=MOD1(N,10)
      I=N-N10+1
      CALL RZERO(XYZN,30)
      IF (N10.GT.0) THEN
         CALL MXM(RMTRX,3,XYZ(1,I),3,XYZN,N10)
         CALL COPY(XYZ(1,I),XYZN,3*N10)
      ENDIF
C
      RETURN
      END

      SUBROUTINE SCALE(XYZL,NL)
C
C     Rescale XYZL such that the mean value of IXX=IYY=IZZ for each element.
C
      INCLUDE 'SIZE'
      INCLUDE 'INPUT'
      DIMENSION XYZL(3,8,LELT)
      COMMON /CTMP0/ VO(LELT),XYZI(3,LELT),CG(3,LELT)
     $              ,TI(6),WORK(6)
C
C     Compute volumes -
C
      CALL VOLUME2(VO,XYZL,NL)
      VTOT=GLSUM (VO,NL)
C
C     Compute (weighted) average inertia for each element.
C
      NCRNR=2**NDIM
      CALL RZERO(TI,6)
      DO 100 IL=1,NL
         VO0 = VO(IL)/VTOT
         CALL INRTIA(XYZI(1,IL),CG(1,IL),XYZL(1,1,IL),NCRNR,1)
         TI(1)=TI(1)+XYZI(1,IL)*VO0
         TI(2)=TI(2)+XYZI(2,IL)*VO0
         TI(3)=TI(3)+XYZI(3,IL)*VO0
         TI(4)=TI(4)+CG(1,IL)  *VO0
         TI(5)=TI(5)+CG(2,IL)  *VO0
         TI(6)=TI(6)+CG(3,IL)  *VO0
  100 CONTINUE
      CALL GOP(TI,WORK,'+  ',6)
      XI  =SQRT(TI(1))
      YI  =SQRT(TI(2))
      ZI  =1.0
      IF (ldim.eq.3) ZI=SQRT(TI(3))
C
C     Rescale ( & shift to a nearly mean zero )
C
      DO 200 IL=1,NL
      DO 200 IC=1,NCRNR
         XYZL(1,IC,IL)=(XYZL(1,IC,IL)-TI(4))/XI
         XYZL(2,IC,IL)=(XYZL(2,IC,IL)-TI(5))/YI
         XYZL(3,IC,IL)=(XYZL(3,IC,IL)-TI(6))/ZI
  200 CONTINUE
C
      RETURN
      END
      SUBROUTINE INRTIA(XYZI,CG,XYZL,N,ITYPE)
C
C     Compute cg and inertia for a collection of unit point masses.
C     This is a global (multiprocessor) operation, only IF itype=2.
C
      DIMENSION XYZI(3),CG(3),XYZL(3,1)
      DIMENSION TI(4),WORK(4)
C
      TI(1)=0.0
      TI(2)=0.0
      TI(3)=0.0
      TI(4)=N
      DO 100 I=1,N
         TI(1)=TI(1)+XYZL(1,I)
         TI(2)=TI(2)+XYZL(2,I)
         TI(3)=TI(3)+XYZL(3,I)
  100 CONTINUE
      IF (ITYPE.EQ.2) CALL GOP(TI,WORK,'+  ',4)
      IF (TI(4).EQ.0.0) TI(4)=1.0
      CG(1)=TI(1)/TI(4)
      CG(2)=TI(2)/TI(4)
      CG(3)=TI(3)/TI(4)
C
      TI(1)=0.0
      TI(2)=0.0
      TI(3)=0.0
      DO 200 I=1,N
         TI(1)=TI(1)+( XYZL(1,I)-CG(1) )**2
         TI(2)=TI(2)+( XYZL(2,I)-CG(2) )**2
         TI(3)=TI(3)+( XYZL(3,I)-CG(3) )**2
  200 CONTINUE
      IF (ITYPE.EQ.2) CALL GOP(TI,WORK,'+  ',3)
      TI(1)=TI(1)/TI(4)
      TI(2)=TI(2)/TI(4)
      TI(3)=TI(3)/TI(4)
      IF (ITYPE.EQ.2) THEN
C        std. def'n of inertia.
         XYZI(1)=TI(2)+TI(3)
         XYZI(2)=TI(3)+TI(1)
         XYZI(3)=TI(1)+TI(2)
      ELSE
         XYZI(1)=TI(1)
         XYZI(2)=TI(2)
         XYZI(3)=TI(3)
      ENDIF
C
      RETURN
      END
      SUBROUTINE VOLUME2(VOL,XYZ,N)
      INCLUDE 'SIZE'
      INCLUDE 'INPUT'
      DIMENSION XYZ(3,2,2,2,1)
      DIMENSION VOL(1)
C
      DO 1000 IE=1,N
         VOL(IE)=0.0
         IF (ldim.eq.3) THEN
           DO 20 K=1,2
           DO 20 J=1,2
           DO 20 I=1,2
              VOL1 = (XYZ(1,2,J,K,IE)-XYZ(1,1,J,K,IE))
     $             * (XYZ(2,I,2,K,IE)-XYZ(2,I,1,K,IE))
     $             * (XYZ(3,I,J,2,IE)-XYZ(3,I,J,1,IE))
              VOL2 = (XYZ(1,2,J,K,IE)-XYZ(1,1,J,K,IE))
     $             * (XYZ(2,I,J,2,IE)-XYZ(2,I,J,1,IE))
     $             * (XYZ(3,I,2,K,IE)-XYZ(3,I,1,K,IE))
              VOL3 = (XYZ(1,I,2,K,IE)-XYZ(1,I,1,K,IE))
     $             * (XYZ(2,2,J,K,IE)-XYZ(2,1,J,K,IE))
     $             * (XYZ(3,I,J,2,IE)-XYZ(3,I,J,1,IE))
              VOL4 = (XYZ(1,I,J,2,IE)-XYZ(1,I,J,1,IE))
     $             * (XYZ(2,I,2,K,IE)-XYZ(2,I,1,K,IE))
     $             * (XYZ(3,I,2,K,IE)-XYZ(3,I,1,K,IE))
              VOL5 = (XYZ(1,I,2,K,IE)-XYZ(1,I,1,K,IE))
     $             * (XYZ(2,I,J,2,IE)-XYZ(2,I,J,1,IE))
     $             * (XYZ(3,2,J,K,IE)-XYZ(3,1,J,K,IE))
              VOL6 = (XYZ(1,I,J,2,IE)-XYZ(1,I,J,1,IE))
     $             * (XYZ(2,I,2,K,IE)-XYZ(2,I,1,K,IE))
     $             * (XYZ(3,2,J,K,IE)-XYZ(3,1,J,K,IE))
              VOL(IE) = VOL(IE)+VOL1+VOL2+VOL3+VOL4+VOL5+VOL6
   20      CONTINUE
           VOL(IE)=VOL(IE)/8.0
         ELSE
C     2-D:
            DO 40 J=1,2
            DO 40 I=1,2
              VOL1 = (XYZ(1,2,J,1,IE)-XYZ(1,1,J,1,IE))
     $             * (XYZ(2,I,2,1,IE)-XYZ(2,I,1,1,IE))
              VOL3 = (XYZ(1,I,2,1,IE)-XYZ(1,I,1,1,IE))
     $             * (XYZ(2,2,J,1,IE)-XYZ(2,1,J,1,IE))
              VOL(IE)=VOL(IE)+VOL1+VOL3
   40      CONTINUE
           VOL(IE)=VOL(IE)/4.0
         ENDIF
         VOL(IE)=ABS(VOL(IE))
 1000 CONTINUE
C
      RETURN
      END
      SUBROUTINE FINDCG(CG,XYZ,N)
C
C     Compute cg for N elements.
C
      INCLUDE 'SIZE'
      DIMENSION CG(3,1),XYZ(3,8,1)
C
      NCRNR=2**NDIM
      CALL RZERO(CG,3*N)
      DO 100 I =1,N
      DO 100 IC=1,NCRNR
         CG(1,I)=CG(1,I)+XYZ(1,IC,I)
         CG(2,I)=CG(2,I)+XYZ(2,IC,I)
         CG(3,I)=CG(3,I)+XYZ(3,IC,I)
  100 CONTINUE
      TMP=1.0/(NCRNR)
      CALL CMULT(CG,TMP,3*N)
      RETURN
      END
      SUBROUTINE DIVIDE(LIST1,LIST2,NL1,NL2,IFOK,LIST,NL,XYZI,CG,wgt)
C
C     Divide the elements associated with this subdomain according to
C     the direction having the smallest moment of inertia (the "long"
C     direction).
C
      INCLUDE 'SIZE'
      INCLUDE 'INPUT'
      INCLUDE 'PARALLEL'
      INCLUDE 'TSTEP'
C
      DIMENSION LIST(LELT),LIST1(LELT),LIST2(LELT)
      DIMENSION XYZI(3),CG(3,LELT),wgt(1)
      COMMON /CTMP0/ XCG(LELT),YCG(LELT),ZCG(LELT)
      REAL IXX,IYY,IZZ
      INTEGER WORK(2),WRK2(2)
      LOGICAL IFOK
C
C     Choose "long" direction:
C
      IXX=XYZI(1)
      IYY=XYZI(2)
      IZZ=XYZI(3)
      IF (ldim.eq.3) THEN
         IF (IXX.LE.IYY.AND.IXX.LE.IZZ) THEN
            DO 104 IE=1,NL
               XCG(IE)=CG(1,IE)
               YCG(IE)=CG(2,IE)
               ZCG(IE)=CG(3,IE)
  104       CONTINUE
         ELSEIF (IYY.LE.IXX.AND.IYY.LE.IZZ) THEN
            DO 106 IE=1,NL
               XCG(IE)=CG(2,IE)
               YCG(IE)=CG(3,IE)
               ZCG(IE)=CG(1,IE)
  106       CONTINUE
         ELSEIF (IZZ.LE.IXX.AND.IZZ.LE.IYY) THEN
            DO 108 IE=1,NL
               XCG(IE)=CG(3,IE)
               YCG(IE)=CG(1,IE)
               ZCG(IE)=CG(2,IE)
  108       CONTINUE
         ENDIF
      ELSE
C     2-D:
         IF (IXX.LE.IYY) THEN
            DO 114 IE=1,NL
               XCG(IE)=CG(1,IE)
               YCG(IE)=CG(2,IE)
  114       CONTINUE
         ELSE
            DO 116 IE=1,NL
               XCG(IE)=CG(2,IE)
               YCG(IE)=CG(1,IE)
  116       CONTINUE
         ENDIF
      ENDIF
      call col2(xcg,wgt,nl)
      call col2(ycg,wgt,nl)
      call col2(zcg,wgt,nl)
C
C     Find median value of CG to determine dividing point:
C
      XM=FMDIAN(XCG,NL,IFOK)
      YM=FMDIAN(YCG,NL,IFOK)
      ZM=0.0
      IF (ldim.eq.3) ZM=FMDIAN(ZCG,NL,IFOK)
C
C     Diagnostics
C
      IF (.NOT.IFOK) THEN
         WRITE(6,130) NID,NL,XM,YM,ZM
         DO 120 IL=1,NL
            WRITE(6,135) NID,IL,XCG(IL),YCG(IL),ZCG(IL)
  120    CONTINUE
  130    FORMAT(I3,'DIVIDE: NL,XM,YM,ZM',I3,3F12.5)
  135    FORMAT(I3,'DIVIDE: NID,IL,XC,YC,ZCG',I4,3F12.5)
      ENDIF
C
C=============================================================
C     Divide LIST into LIST1 (XCG < XM) and LIST2 (XCG>XM).
C=============================================================
C
      NL1=0
      NL2=0
      DO 200 IE=1,NL
         IF (XCG(IE).LT.XM) THEN
            NL1=NL1+1
            LIST1(NL1)=LIST(IE)
         ENDIF
         IF (XCG(IE).GT.XM) THEN
            NL2=NL2+1
            LIST2(NL2)=LIST(IE)
         ENDIF
         IF (XCG(IE).EQ.XM) THEN
C
C           We have to look at the other directions to arrive at
C           a unique subdivision algortithm.
C
C
C           More Diagnostics
C
            IF (.NOT.IFOK) WRITE(6,201) NID,IE,XCG(IE),XM
  201    FORMAT(I3,'DIVIDE: IE,XCG,XM:',I4,3F12.5)
C
            IF (YCG(IE).LT.YM) THEN
               NL1=NL1+1
               LIST1(NL1)=LIST(IE)
            ENDIF
            IF (YCG(IE).GT.YM) THEN
               NL2=NL2+1
               LIST2(NL2)=LIST(IE)
            ENDIF
            IF (YCG(IE).EQ.YM) THEN
C              look at 3rd direction.
               IF (ldim.eq.3 .AND. ZCG(IE).LT.ZM) THEN
                  NL1=NL1+1
                  LIST1(NL1)=LIST(IE)
               ELSE IF (ldim.eq.3 .AND. ZCG(IE).GT.ZM) THEN
                  NL2=NL2+1
                  LIST2(NL2)=LIST(IE)
               ELSE
C                 for 2- or 3-D intdeterminate case:
                  NL1=NL1+1
                  LIST1(NL1)=LIST(IE)
               ENDIF
            ENDIF
C
         ENDIF
  200 CONTINUE
C
C     Check for an even distribution (i.e. - not different by
C     more than 1):
C
      IFOK=.TRUE.
      WORK(1)=NL1
      WORK(2)=NL2
      CALL IGOP(WORK,WRK2,'+  ',2)
      IF (ABS(WORK(1)-WORK(2)).GT.1) IFOK=.FALSE.
C
      RETURN
      END
      SUBROUTINE GRAY(IPG,IPG1,ITMP,N)
      DIMENSION IPG(1),IPG1(1),ITMP(1)
      INTEGER CD
C
      CD=LOG2(N)
      NPR = 1
      IPG(1) = 1
      DO 100 I=1,CD
         N1  = NPR+1
         N2  = NPR*2
         CALL ICOPY(IPG(N1),IPG(1),NPR)
         CALL IADD (IPG(N1),NPR,NPR)
         CALL IFLIP(IPG(N1),NPR)
         NPR = 2*NPR
  100 CONTINUE
      N1=NPR+1
c     IPG(0)=IPG(NPR)
c     IPG(N1)=IPG(1)
C
C     Compute the inverse of the gray code mapping.  In other words,
C     given the ith entry on the gray code list, IPG(i) returns the
C     appropriate Node number (=nid+1).  Given a node number, NODE,
C     IPG1(NODE) returns the location in the gray code (i.e. ring) map.
C
      CALL ICOPY(ITMP,IPG ,NPR)
      CALL ISORT(ITMP,IPG1,NPR)
C
      RETURN
      END
c-----------------------------------------------------------------------
      subroutine chk_nel
      include 'SIZE'
      include 'TOTAL'

      neltmx=np*lelt
      nelvmx=np*lelv

      neltmx=min(neltmx,lelg)
      nelvmx=min(nelvmx,lelg)

      nelgt = iglmax(nelgt,1)
      nelgv = iglmax(nelgv,1)

c     write(6,*) nid,' inside chk_nel',nelgt,neltmx,nelvmx

      if (nelgt.gt.neltmx.or.nelgv.gt.nelvmx) then
         if (nid.eq.0) then
          lelt_needed = nelgt/np
          if (mod(nelgt,np).ne.0) lelt_needed = lelt_needed + 1
          write(6,12) lelt,lelg,lelt_needed,np,nelgt
 12         format(//,2X,'ABORT: Problem size too large!'
     $         ,/,2X
     $         ,/,2X,'This solver has been compiled for:'
     $         ,/,2X,'   number of elements/proc  (lelt):',i12
     $         ,/,2X,'   total number of elements (lelg):',i12
     $         ,/,2X
     $         ,/,2X,'Recompile with the following SIZE  parameters:'
     $         ,/,2X,'   lelt >= ',i12,'  for np = ',i12
     $         ,/,2X,'   lelg >= ',i12,/)
c           write(6,*)'help:',lp,np,nelvmx,nelgv,neltmx,nelgt
c           write(6,*)'help:',lelt,lelv,lelgv
         endif
         call exitt(1)
      endif

      if(nelgt.gt.nelgt_max) then
        if(nid.eq.0) write(6,*)
     $               'ABORT: Total number of elements too large!',
     $               '       nel_max = ', nelgt_max
        call exitt(1)
      endif

      if (nelt.gt.lelt) then
        write(6,'(A,3I12)') 'ABORT: nelt>lelt!', nid, nelt, lelt
        call exitt(1)
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine cscan(sout,key,nk)

      character*132 sout,key
      character*132 string
      character*1  string1(132)
      equivalence (string1,string)
c
      do i=1,100000000
         call blank(string,132)
         read (nk,80,end=100,err=100) string
         call chcopy(sout,string,132)
c        write (6,*) string
         if (indx1(string,key,nk).ne.0) return
      enddo
  100 continue
c
   80 format(a132)
      return

      end
c-----------------------------------------------------------------------
      subroutine open_bin_file(ifbswap) ! open file & chk for byteswap

      include 'SIZE'
      include 'TOTAL'

      logical ifbswap,if_byte_swap_test

      integer fnami (33)
      character*132 fname
      equivalence (fname,fnami)

      character*132 hdr
      character*5 version
      real*4      test

      if (nid.eq.0) write(6,*) 'read .re2 file'

      ierr=0
      if (nid.eq.0) then
         call izero(fnami,33)
         m = indx2(re2fle,132,' ',1)-1
         call chcopy(fname,re2fle,m)

         call byte_open(fname,ierr)
         if(ierr.ne.0) goto 100
         call byte_read(hdr,20,ierr)
         if(ierr.ne.0) goto 100

         read (hdr,1) version,nelgt,ndum,nelgv
    1    format(a5,i9,i3,i9)

         wdsizi = 4
         if(version.eq.'#v002') wdsizi = 8

         call byte_read(test,1,ierr)
         if(ierr.ne.0) goto 100
         ifbswap = if_byte_swap_test(test,ierr)
         if(ierr.ne.0) goto 100

      endif

 100  call err_chk(ierr,'Error opening or reading .re2 header. Abort.$')

      call bcast(wdsizi ,ISIZE)
      call bcast(ifbswap,LSIZE)
      call bcast(nelgv  ,ISIZE)
      call bcast(nelgt  ,ISIZE)


      if(wdsize.eq.4.and.wdsizi.eq.8) then
         call exitti('wdsize=4 & wdsizi(re2)=8 not compatible$',wdsizi
     $        ,1)
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine bin_rd1(ifbswap)  ! read mesh, curve, and bc info

      include 'SIZE'
      include 'TOTAL'
      include 'CTIMER'

      logical ifbswap


      etime1 = dnekclock()

      ibc   = nfield
      nfldt = nfield

c
c     If p32 = 0.1, there will be no bcs read in
c
c     if (param(32).gt.0) nfldt = ibc + param(32)-1

      lcbc=18*lelt*(ldimt1 + 1)
      call blank(cbc,lcbc)

      if (nid.eq.0) write(6,*)    '  reading mesh '
      call bin_rd1_mesh  (ifbswap)   ! version 1 of binary reader
      if (nid.eq.0) write(6,*) '  reading curved sides '
      call bin_rd1_curve (ifbswap)

      do ifld = ibc,nfldt
         if (nid.eq.0) write(6,*) '  reading bc for ifld',ifld
         call bin_rd1_bc (cbc(1,1,ifld),bc(1,1,1,ifld),ifbswap)
      enddo

      call nekgsync
      ierr=0
      if(nid.eq.0) then
        call byte_close(ierr)
        write(6,*) 'done :: read .re2 file'
        write(6,*) ' '
      endif

      return
      end

c-----------------------------------------------------------------------
      subroutine bin_rd1_mesh(ifbswap)    ! version 1 of binary reader
      include 'SIZE'
      include 'TOTAL'
      logical ifbswap

      integer e,eg,buf(55)

      nwds = (1 + ndim*(2**ndim))*(wdsizi/4) ! group + 2x4 for 2d, 3x8 for 3d
      len  = 4*nwds                          ! 4 bytes / wd

      if (nwds.gt.55.or.isize.gt.4) then
         write(6,*) nid,' Error in bin_rd1_mesh: buf size',nwds,isize
         call exitt(1)
      endif

      call nekgsync()

      nio = 10
      do k=1,8
         if (nelgt/nio .lt. 100) goto 10
         nio = nio*10
      enddo
   10 continue

      ierr  = 0
      ierr2 = 0
      len1  = 4

      do eg=1,nelgt             ! sync NOT needed here

         mid = gllnid(eg)
         e   = gllel (eg)
#ifdef DEBUG
         if (nid.eq.0.and.mod(eg,nio).eq.0) write(6,*) eg,' mesh read'
#endif
         if (mid.ne.nid.and.nid.eq.0) then              ! read & send

            if(ierr.eq.0) then
              call byte_read  (buf,nwds,ierr)
              call csend(eg,ierr,len1,mid,0)
              if(ierr.eq.0) call csend(eg,buf,len,mid,0)
            else
              call csend(eg,ierr,len1,mid,0)
            endif

         elseif (mid.eq.nid.and.nid.ne.0) then          ! recv & process

            call crecv      (eg,ierr,len1)
            if(ierr.eq.0) then
              call crecv      (eg,buf,len)
              call buf_to_xyz (buf,e,ifbswap,ierr2)
            endif
         elseif (mid.eq.nid.and.nid.eq.0) then          ! read & process

            if(ierr.eq.0) then
              call byte_read  (buf,nwds,ierr)
              call buf_to_xyz (buf,e,ifbswap,ierr2)
            endif
         endif

      enddo
      ierr = ierr + ierr2
      call err_chk(ierr,'Error reading .re2 mesh. Abort. $')

      return
      end
c-----------------------------------------------------------------------
      subroutine bin_rd1_curve (ifbswap) ! v. 1 of curve side reader
      include 'SIZE'
      include 'TOTAL'
      logical ifbswap

      integer e,eg,buf(55)
      real rcurve

      nwds = (2 + 1 + 5)*(wdsizi/4) !eg+iside+ccurve+curve(6,:,:) !only 5 in rea
      len  = 4*nwds      ! 4 bytes / wd

      if (nwds.gt.55.or.isize.gt.4) then
         write(6,*)nid,' Error in bin_rd1_curve: buf size',nwds,isize
         call exitt(1)
      endif

      call nekgsync()

      ierr = 0
      len1 = 4
      if (nid.eq.0) then  ! read & send/process

         if(wdsizi.eq.8) then
           call byte_read(rcurve,2,ierr)
           if (ifbswap) call byte_reverse8(rcurve,2,ierr)
           ncurve = rcurve
         else
           call byte_read(ncurve,1,ierr)
           if (ifbswap) call byte_reverse(ncurve,1,ierr)
         endif

         do k=1,ncurve
           if(ierr.eq.0) then
              call byte_read(buf,nwds,ierr)
              if(wdsizi.eq.8) then
                if(ifbswap) call byte_reverse8(buf,nwds-2,ierr)
                call copyi4(eg,buf(1),1)  !1,2
              else
                if (ifbswap) call byte_reverse(buf,nwds-1,ierr) ! last is char
                eg  = buf(1)
              endif

              mid = gllnid(eg)
              if (mid.eq.0.and.ierr.eq.0) then
                 call buf_to_curve(buf)
              else
                 if(ierr.eq.0) then
                   call csend(mid,buf,len,mid,0)
                 else
                   goto 98
                 endif
              endif
           else
              goto 98
           endif
         enddo
  98     call buf_close_out  ! notify all procs: no more data

      else               ! wait for data from node 0

         ncurve_mx = 12*nelt
         do k=1,ncurve_mx+1   ! +1 to make certain we receive the close-out

            call crecv(nid,buf,len)
            if(wdsizi.eq.8) then
               call copyi4(ichk,buf(1),1)
               if(ichk.eq.0) goto 99
               call buf_to_curve(buf)
            elseif (buf(1).eq.0) then
               goto 99
            else
               call buf_to_curve(buf)
            endif

         enddo
   99    call buf_close_out

      endif
      call err_chk(ierr,'Error reading .re2 curved data. Abort.$')


      return
      end
c-----------------------------------------------------------------------
      subroutine bin_rd1_bc (cbl,bl,ifbswap) ! v. 1 of bc reader
      include 'SIZE'
      include 'TOTAL'
      logical ifbswap

      character*3 cbl(6,lelt)
      real         bl(5,6,lelt)

      integer e,eg,buf(55)
      real rbc_max

      nwds = (2 + 1 + 5)*(wdsizi/4)   ! eg + iside + cbc + bc(5,:,:)
      len  = 4*nwds      ! 4 bytes / wd

      if (nwds.gt.55.or.isize.gt.4) then
         write(6,*) nid,' Error in bin_rd1_bc: buf size',nwds,isize
         call exitt(1)
      endif

      do e=1,nelt   ! fill up cbc w/ default
      do k=1,6
         cbl(k,e) = 'E  '
      enddo
      enddo

      call nekgsync()
      ierr=0
      len1=4
      if (nid.eq.0) then  ! read & send/process

         if(wdsizi.eq.8) then
           call byte_read(rbc_max,2,ierr)
           if (ifbswap) call byte_reverse8(rbc_max,2,ierr) ! last is char
           nbc_max = rbc_max
         else
           call byte_read(nbc_max,1,ierr)
           if (ifbswap) call byte_reverse(nbc_max,1,ierr) ! last is char
         endif

         do k=1,nbc_max
            if(ierr.eq.0) then
               call byte_read(buf,nwds,ierr)
               if(wdsizi.eq.8) then
                 if (ifbswap) call byte_reverse8(buf,nwds-2,ierr)
                 call copyi4(eg,buf(1),1) !1&2 of buf
               else
                 if (ifbswap) call byte_reverse(buf,nwds-1,ierr) ! last is char
                 eg  = buf(1)
               endif
               mid = gllnid(eg)
c              write(6,*) k,' dobc3 ',eg,mid

               if (mid.eq.0.and.ierr.eq.0) then
                   call buf_to_bc(cbl,bl,buf)
               else
c                  write(6,*) mid,' sendbc1 ',eg
                   if(ierr.eq.0) then
                     call csend(mid,buf,len,mid,0)
                   else
                     goto 98
                   endif
c                  write(6,*) mid,' sendbc2 ',eg
               endif
C              write(6,*) k,' dobc2 ',nbc_max,eg
            else
               goto 98
            endif
         enddo
c        write(6,*) mid,' bclose ',eg,nbc_max
  98     call buf_close_outv ! notify all procs: no more data

      else               ! wait for data from node 0

         nbc_max = 2*ndim*nelt
         do k=1,nbc_max+1  ! Need one extra !

c           write(6,*) nid,' recvbc1',k
            call crecv(nid,buf,len)
c           write(6,*) nid,' recvbc2',k,buf(1)

            if(wdsizi.eq.8) then
               call copyi4(ichk,buf(1),1)
               if(ichk.eq.0) goto 99
               call buf_to_bc(cbl,bl,buf)
            elseif (buf(1).eq.0) then
                goto 99
            else
                call buf_to_bc(cbl,bl,buf)
            endif

         enddo
   99    call buf_close_outv

      endif

      call err_chk(ierr,'Error reading boundary data for re2. Abort.$')

      return
      end
c-----------------------------------------------------------------------
      subroutine bufchk(buf,n)
      integer n
      real buf(n)
      do i=1,n
         write(6,*) buf(i), ' whhhh'
      enddo
      return
      end
c-----------------------------------------------------------------------
      subroutine buf_close_outv  ! this is the stupid O(P) formulation

      include 'SIZE'
      include 'PARALLEL'

      integer*4 zero
      real      rzero

      len   = wdsizi
      rzero = 0
      zero  = 0
c     write(6,*) nid,' bufclose'
      if (nid.eq.0) then
         do mid=1,np-1
            if(wdsizi.eq.8)call csend(mid,rzero,len,mid,0)
            if(wdsizi.eq.4)call csend(mid, zero,len,mid,0)
c           write(6,*) mid,' sendclose'
         enddo
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine buf_close_out  ! this is the stupid O(P) formulation

      include 'SIZE'
      include 'PARALLEL'

      integer*4 zero
      real      rzero

c     len  = 4
      len   = wdsizi
      zero = 0
      rzero = 0
      if (nid.eq.0) then
         do mid=1,np-1
            if(wdsizi.eq.8)call csend(mid,rzero,len,mid,0)
            if(wdsizi.eq.4)call csend(mid, zero,len,mid,0)
         enddo
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine buf_to_bc(cbl,bl,buf)    ! version 1 of binary reader

      include 'SIZE'
      include 'TOTAL'

      character*3  cbl(6,lelt)
      real         bl(5,6,lelt)

      integer e,eg,f,buf(30)


      if(wdsizi.eq.8) then
        call copyi4(eg,buf(1),1) !1-2
        e  = gllel(eg)

        call copyi4(f,buf(3),1) !3-4

        call copy  (bl(1,f,e),buf(5),5) !5--14
        call chcopy(cbl( f,e),buf(15),3)!15-16

        if(nelt.ge.1000000.and.cbl(f,e).eq.'P  ')
     $   call copyi4(bl(1,f,e),buf(5),1) !Integer assign connecting P element

      else
        eg = buf(1)
        e  = gllel(eg)
        f  = buf(2)

        call copy4r ( bl(1,f,e),buf(3),5)
        call chcopy (cbl(  f,e),buf(8),3)

        if (nelgt.ge.1 000 000.and.cbl(f,e).eq.'P  ')
     $     bl(1,f,e) = buf(3) ! Integer assign of connecting periodic element
      endif

c     write(6,1) eg,e,f,cbl(f,e),' CBC',nid
c  1  format(2i8,i4,2x,a3,a4,i8)

      return
      end
c-----------------------------------------------------------------------
      subroutine buf_to_curve(buf)    ! version 1 of binary reader

      include 'SIZE'
      include 'TOTAL'

      integer e,eg,f,buf(30)

      if(wdsizi.eq.8) then
        call copyi4(eg,buf(1),1) !1-2
        e  = gllel(eg)

        call copyi4(f,buf(3),1) !3-4

        call copy  ( curve(1,f,e),buf(5) ,5) !5--14
        call chcopy(ccurve(  f,e),buf(15),1)!15
      else
        eg = buf(1)
        e  = gllel(eg)
        f  = buf(2)

        call copy4r( curve(1,f,e),buf(3),5)
        call chcopy(ccurve(f,e)  ,buf(8),1)
      endif

c     write(6,1) eg,e,f,(curve(k,f,e),k=1,5),ccurve(f,e)
c   1 format(2i7,i3,5f10.3,1x,a1,'ccurve')

      return
      end
c-----------------------------------------------------------------------
      subroutine buf_to_xyz(buf,e,ifbswap,ierr)    ! version 1 of binary reader

      include 'SIZE'
      include 'TOTAL'
      logical ifbswap


      integer e,eg,buf(0:49)

      nwds = (1 + ndim*(2**ndim))*(wdsizi/4) ! group + 2x4 for 2d, 3x8 for 3d

      if     (ifbswap.and.ierr.eq.0.and.wdsizi.eq.8) then
          call byte_reverse8(buf,nwds,ierr)
      elseif (ifbswap.and.ierr.eq.0.and.wdsizi.eq.4) then
          call byte_reverse (buf,nwds,ierr)
      endif
      if(ierr.ne.0) return

      if(wdsizi.eq.8) then
         call copyi4(igroup(e),buf(0),1) !0-1
         if (ndim.eq.3) then
            call copy  (xc(1,e),buf( 2),8) !2 --17
            call copy  (yc(1,e),buf(18),8) !18--33
            call copy  (zc(1,e),buf(34),8) !34--49
         else
            call copy  (xc(1,e),buf( 2),4) !2 --9
            call copy  (yc(1,e),buf(10),4) !10--17
          endif
      else
         igroup(e) = buf(0)
         if (ldim.eq.3) then
            call copy4r(xc(1,e),buf( 1),8)
            call copy4r(yc(1,e),buf( 9),8)
            call copy4r(zc(1,e),buf(17),8)
         else
            call copy4r(xc(1,e),buf( 1),4)
            call copy4r(yc(1,e),buf( 5),4)
         endif
      endif

      return
      end
c-----------------------------------------------------------------------
